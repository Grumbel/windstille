SubDir TOP src scripting ;

if $(LEX) && $(BISON) {
    MINISWIG_AVAILABLE = 1 ;
} else {
    MINISWIG_AVAILABLE = ;
}

if $(MINISWIG_AVAILABLE)
{
    ##  MiniSwigRule outputcppfile : inputfile : modulename : flags
    rule MiniSwigRule
    {
        local sources = [ SearchSource $(>) ] ;
        local cppfile = [ LocateTarget $(<) : $(SUBDIR) ] ;
        local headerfile = [ LocateTarget $(<:S=.hpp) : $(SUBDIR) ] ;	
        SEARCH on $(headerfile) = $(SOURCH_SOURCE) ;

        Depends $(cppfile) : $(headerfile) ;
        MiniSwig $(cppfile) : $(sources) ;
        CPPFLAGS on $(cppfile) = $(CPPFLAGS) -DSCRIPTING_API ;
        headerfile on $(cppfile) = $(headerfile) ;
        modulename on $(cppfile) = $(3) ;
        FLAGS on $(cppfile) = $(4) ;

        local object = [ CompileObject $(cppfile) ] ;

        return $(object) ;
    }

    rule MiniSwig
    {
        Depends $(<) : $(>) $(MINISWIG) ;
    }

    actions MiniSwig bind headerfile
    {
        $(CPP) -x c -CC $(CPPFLAGS) $(>) -o $(LOCATE_OBJECTS)/miniswig.tmp
        $(top_builddir)/miniswig --output-cpp $(<) --input $(LOCATE_OBJECTS)/miniswig.tmp --output-hpp $(headerfile) --module $(modulename) $(FLAGS)
#       rm -f $(LOCATE_OBJECTS)/miniswig.tmp
    }
}

scripting_sources = [ Filter [ Wildcard *.cpp *.hpp ] : wrapper.cpp wrapper.hpp ] ;
if ! $(MINISWIG_AVAILABLE)
{
    scripting_sources += [ SearchSource wrapper.cpp ] ;
}
scripting_objects = [ CompileObjects $(scripting_sources) ] ;
if $(MINISWIG_AVAILABLE)
{
    scripting_objects += 
        [ MiniSwigRule wrapper.cpp : wrapper.interface.hpp : windstille : --select-namespace Scripting ] ;
}

TRANSLATABLE_SOURCES += [ SearchSource $(scripting_sources) ] ;
