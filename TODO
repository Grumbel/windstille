Windstille ToDo
===============

This is a list of tasks and issues that might be worth to implement or
fix. This list is however not an authorative list of things that must
be done, its a collection of random things that pop up during
development, therefore not everything in here might be well thought
out or worth to implement. Use your brain before implementing anything
on this list and always thing about how useful a new feature would be
in the context of the whole game.

Scripting
=========

* ParticleSystem could be hooked up to scripting

* add a way to bind keys to script functions for use in debugging

  bind("F9", "toggle_this")
  bind("F9", function() { /* do stuff */ })

* maybe: introduce some cleaner seperation between scripts that are
  allowed to suspend and those that aren't

  - name them differently
  - name their trigger/hooks differently
  - remove suspendable functions from roottable
  - put suspendable functions into a different namespace
  - ...

* NavigationGraph needs hooks into scripting, so that things can be
  triggered when a character passes over a specific trigger node or
  things like that.

* add function that clears all scripts and rereads them from file (for
  debugging)

* add check that looks into a scripts root table to see if init()
  and/or run() is present

* add ability to wait on custom event and add ability to fire of a
  custom event:

    wait_for("bob arrives at bar");
    ...
    fire("bob arrives at bar");

  also add abilty for callbacks:

    register_callback("bob arrives at bar", function(){
       // do stuff
    });

  In which VM shall this be executed? In a new one? Wouldn't that be
  the same as:

    spawn_function(function(){
       // needed so that the callback can be called multiple times 
       while(true) { 
         wait_for("bob arrives at bar");
         // do stuff
       }
    });

  Also an ability to create unique events could be useful (not clear
  for exactly what, so implementation can wait):

    shared.event_id <- wait_for_unique_event()
    ...
    fire(shared.event_id);

* think about if scripts spawned in a sector should be parented to the
  sectors init script or to the root_vm, the later one is currently
  the case, the first one however would make it easier to share
  variables between scripts, on the other shared variable should often
  be available across sectors, so a better sharing mechanism is likely needed

  -> scripts could share state via a 'state' table defined in windstille.nut

* add option to SquirrelThread to be removed after its done or removed
  when a specific function is called (useful for spawning functions)

* reentering a sector twice barfs because:

  std::exception: Squirrel error: sectors/apartment/init.nut:
  SquirrelThread: couldn't call 'run' (sectors/apartment/flicker.nut:
  ScriptManager::run_script(): Script must be idle to be 'run()')

* ScriptableObject is a bad name, since all objects should be
  scriptable in one form or another

* implement more advanced tab-completion for console

* miniswig does not support __suspend with a return value, should be
  fixed, since Squirrel can handle it. Trouble is that the return
  value is created by the sq_wakeupvm() call, not by the
  sq_suspendvm() one, so its not actually in the wrapper code, but in
  the normal C++ code

  Return value has problem, works in same cases, but returns NULL for
  barrobot.nut in apartment.wst

* Currently we wakeup on conditions that are broadcasted to all
  scripts, in some situation it might make more sense to attach the
  script directly to the object that sends the signal

* some functions in data/scripts/windstille.nut require '::' before
  them so that they can be found, not quite clear why or exactly when
  this happens, seems to happen only in classes, not in normal
  function, in theory at least they should get resolved by delegation
  from the current environment to the roottable, but that doesn't
  happen

* objects are currently all exported to squirrel, while we should
  probally use id-tags and accessor functions instead:

  bob = get_object("barkeeper")
  bob.say()

* player can launch PDA or inventory when in a dialog, this will break
  the script

* currently the ScriptManager is global, meaning scripts are never
  cleaned up on Sector changes, this needs to be fixed

* figure out proper 'namespaces' for the scripting, i.e. gfx_ or
  video_ for all display related stuff and so on, so that
  tab-completion works better and things become more readable

* conversations really should be data with hooks for scripts, not pure
  scripts (FIXME: not clear if there is enough benefit and flexibilty
  to try that)

* print and println behave different on console (?)

Input Handling
==============

* input in Navigation Graph test uses deadzone, but shouldn't

* remove secondary controller, instead accept multiple --controller
  options and store the files in a list

* analog trigger handling is a little problematic, since the axis is
  neutral at -32768, not at 0.

* src/input/controller.hpp should keep not only the current state, but
  also the last state, this would allow proper detection of button
  presses and axis movements over a threshold

* Input deadzone is problematic when trying to get angle of a stick,
  deadzone needs to act different there then when X/Y are handled
  seperatly. Temporary workaround is to move deadzone out of the input
  code into the app code, which is problematic as well. Alternatives
  might be more high-level ways to access the stick:

  void get_stick_state(X_AXIS, Y_AXIS, &angle, &length);
  bool stick_is_centered(X_AXIS, Y_AXIS);
  float get_axis_state(X_AXIS, bool ignore_deadzone = false);

* change of input context is troublesome: when the user selects a
  dialog and confirms it, the character starts to walk into the
  direction that the player indicated, because the stick still points
  in that direction after OK_BUTTON is pressed.

  Possible solution: wait till the controller is in neutral position
  before sending events to the next Screen

* reconfigure the controls to behave like Tomb Raider (Xbox360 pad:
  A:jump, B:duck, X:run, Y:interact), move PDA elsewhere

* implement proper dead-zone in input handling

* allow to load multiple controller config files at once

* add zoom via xbox360 analog trigger buttons

* mouse support for menu

Sound Handling
==============

* split music, voice and sound fx into seperate context or allow to
  change their volume by other means

Miscellaneous
=============

* replace power_of_two function with one not based on a slow while() loop

* maybe add special support for opaque textures, i.e. Textures with
  1-bit alpha, which could be used to bucket sort drawing requests and
  reduce texture switches (in case those ever start posing a problem)

* Write a texture packer: http://www.blackpawn.com/texts/lightmaps/default.html

* Display::aspect_size is ugly, turn that into a Display::set_size();

* move particle system into library

* replace lisp::Writer with custom FileWriter (used in config)

* make FileReader work more like lisp::Writer, i.e. less
  const/functional, keeping the current cursor position. Main issue
  with the current FileReader is the way sections are handled, which
  isn't pretty

* image-grid in Sprite seems broken

* remove GameObject::get_world(), use Sector::current() instead
  (difference might matter on sector change)

* move has_suffix, has_prefix and stuff into StringUtil class

* get rid of global debug

* work on Object introspection, see: ~/projects/lang/c++/introspection.cpp

  class GameObject {
    PropertiesClass property_class() {
      static PropertyClass* this_class = 0;
      if (!this_class) {
                 
      } else {

      }
    }
    Properties properties() {
       static PropertiesClass this_class;
       if (!PropertiesClass 
    }
  }

* remove DEBUG macro or give it a clearer defined purpose, currently
  used only in a few tiny places

* add way to TextArea to layout text with a fixed indent after a linebreak:

  Bob: "Hi, how are you, yada yada yada yada yada yada
        yada yada yada yada yada yada yada yada yada yada
        yada yada yada"

* add Ctrl-k, Ctrl-k shortcuts to console

* save command history of the console between runs

* move the concept of parenting into .scm
  
  (scriptable-object 
       (parent "player")
       ...)

  tricky since parent name can't be resolved at object creation, only
  later

* extend the concept of parenting to other(all?) objects

* write "objects/decal.cpp" class, i.e. simple Surface class for
  non-animated objects:

  (decal (pos x y) 

         ;; relative to pos
         (quad x1 y1 ;; defaults to Rectf(Vector2f(0, 0), imagesize)
               x2 y2
               x3 y3
               x4 y4)
         (image "images/greychess.png")
         (layer "color")
         )

* Display::push/pop_cliprect() doesn't handle different aspect-ratios properly

* lightmap is broken with non-standard aspect-ratio

* why does src/navigation/node.hpp use SegmentPosition? Doesn't seem
  right

* set dynamic maximum size for auto resizing Menus depending on
  resolution

* add way to jump without running

* animation must be less strongly coupled to movement

* add way to skip through SpeechManager Speech lines (B-button)

* raycasting in laserpointer is broken, doesn't work if angle is 0
  (maybe not worth to fix since it will be replaced with
  NavigationMesh)

* get rid of global game_time variable

* map laserpointer to the second analog-stick, make mapping absolute,
  not relative

* maybe create an additional layer in SceneContext for drawing things
  like Speech and other worldspace GUI elements to it

* implement proper word wrap in SpeechManager and also add code to
  'unstuck' speech bubbles when they go over the window border.

  Also SpeechManager should act in worldspace, not screenspace or
  something clever inbetween.

* cleanup TextArea/text_area.cpp, having scrolling and running text
  together doesn't make all that much sense, also functions are too
  large

  Scrollbar is to far on the left, outside of the actual Rect, need to
  shrink horizontal width if text needs a scrollbar

* scrap inventory and redesign it

* When starting sector directly from command line, "Return to title screen" doesn't work

* console doesn't adopt to screen size

* create a UTF32 string class for use in console, basically
  basic_string<uint32_t> and a convert function to UTF-8 should be
  enough

* join Player and Character somewhat or derive one from the other, so
  that one can have scripted people running and jumping around

* implement aspect-ration switching at runtime (menu entry is there,
  just no code) and change default screen ration to that seen in the
  artwork pictures (FIXME: full resolution switch would be more useful
  then just aspect-ratio switch)

* add support for empty sectors (sectors without a player character,
  for use in intro.wst and similar cutscenes)

* HUD elements are whole screens, should be something simpler, also a
  seperation between HUD (energybar, speech, etc.) and Overlays
  (inventory, PDA, etc.) might be good

* do not save command line options given on the command line by
  default or add a --vanilla option or so

  or
   
  rewrite Config class and properly seperate config from command line
  and config done via option menu, i.e. command line settings
  shouldn't be persistent unless told so

* make lightmap resolution independent (done, but an artifact remains
  when the resolution isn't dividable by LIGHTMAP_DIV):

  1680x1050 -> 1050 / 4 -> 262.5 -> 262 * 4 -> 1048

  two pixel missing at the bottom

* Specify the capabilites that the different subsystems need to have

* make Console not derive from ostream

OpenGL
======

* check for features before using them:

glewInit();
if (glewIsSupported("GL_VERSION_2_0"))
printf("Ready for OpenGL 2.0\n");
else {
printf("OpenGL 2.0 not supported\n");
exit(1);
}

Profiling
=========

* figure out why running the game engine is extremely slow in
  valgrind, while pause menu is fast

* gprof results:

 16.90      0.60     0.60    47535     0.00     0.00  TileMap::draw(SceneContext&)
 15.21      1.14     0.54 37910690     0.00     0.00  VertexArrayDrawingRequest::texcoord(float, float)
 14.37      1.65     0.51 37974070     0.00     0.00  VertexArrayDrawingRequest::vertex(float, float, float)
 11.55      2.06     0.41    79225     0.00     0.00  Sprite3D::draw(Vector2f const&, Matrix const&) const
  3.94      2.20     0.14  1133610     0.00     0.00  OpenGLState::activate()

Bugs
====

* quickly tapping forward-back-hold down forward makes your character
  play the walking animation without actually moving anywhere
   
* Pressing left (or right), jump and and run at the same time throws an
  exception that causes the game to exit:

  std::exception: No marker with name 'RightFoot' defined in action 'Stand'

  in general the game shouldn't crash when stuff isn't found, but
  instead fallback to placeholders and give a error message on the console

* miniswig causes bison++ to crash

3D Things
==========

* bone animation

* change the game to a righthand coordinate system

Level Design
============

* create a test sector that as open sky, currently most test levels
  are indoor

* fix the particle system in newformat2.wst, speed/lifetime is wrong

* implement light switches in apartment

  Currently the light switch-off sequence is done in the use script,
  this however makes it blocking, it would be nice if the switch-off
  sequence could be handled in a seperate script, but that would
  require a way to apport that script, since else a switch-on could
  collide with a switch-off script

  possible solution:

  function init() {
    lamp_sequence = spawn_script_norun("lamp_sequence.nut");
  }

  function init() {
      ...
      lamp_sequence.call("switch_on");
      ...
      lamp_sequence.call("switch_off");
      ...
  }

  The lamp_sequence.nut script would take control over the process and
  buffer call's when it is busy, once no longer busy it would pick the
  next task from the stack. Different scripts could use different
  stack behaviour, i.e. in the lamp_sequence() it would be useful to
  have a task-stack of size 1 and discard everything else.

  In addition to spawning a script, it would be good if there would be
  a way to spawn an object or a function, since that way the logic can
  be kept in one file.

  spawn_function(function() {
     obj <- FoobarObject();
     obj.run();
  })

* implement a door with two segments that slide sideways when the door
  opens, think about how that can be implemented properly in scripting
  (two parallel events that have to be waited for)

  -> a solution in scripting isn't a good idea here, this is something
     that would be much better solved by a 2D animation system
  

Random Things
=============

* add a music player that allows to play all music files of Windstille

* UTF8 support is missing in:
  
  - BabyXML
  - TTFFont
  - Console

* Add more markup to TextArea: (not really needed with LucasArts-like dialog)
    <font color="#ffbbcc"></font>: Use arbitary color
    <b></b>: make text properly bold
    <i></i>: make text properly italic 

* create a mission that is playable

* add line numbers to error messages from lisp

* rotation in 3d model viewer feels a little weird, could maybe be
  improved somehow

* using a non-square pixel aspect ratio leads to ugly fonts, fonts
  could be rendered with that aspect ratio in mind so that they are
  'pixel-perfect', instead of scaled by OpenGL. This requires:

  - a UI that is reasonably flexible to handle changes in font size
  - some code that scales/unscales the Font before drawing it

* update random number generator:
  http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html

Graphics
========

* do *NOT* use power of two textures, use multiple of 64/128 instead
  (128 is easy to snap, power of two doesn't help, since textures are packed)

* generate .png's automatically from .xcf's via scons

* figure out a way how to properly organize graphics/decal

* Model lower-poly version of Jane and stuff

* aspect-ratio/resolution options:

  - let the user select a resolution from all the ones that are available from X11 (see Pingus for code)
  - have "aspect-ratio: auto" (calc from resolution) and 5:4, 4:3, 16:9, 16:10 overrides

* remodel titlescreen as 3D model

* setting glLineWidth() leads to some interesting artefacts on the
  menus which might be a cool effect

Editor
======

* Texture::put can't handle non-RGBA surface

* add a SoftwareSurface::grow() which creates a new SoftwareSurface
  with a 1px boarder for fixing texture blend issue

* add way to convert Texture to SoftwareSurface for debugging

* share SoftwareSurface via Manager class

* add binlocate support

* add an icon to the editor

* remove the empty default sector when loading another level and the
  default sector hasn't been modified

* add a way to adjust the ambient lighting (button to change color) 

* maybe make Layers not be hardwired into the level struture, but add
  them as independed meta-data:
 
  (layers
    (layer (objects 1)
           (child-layers
             (layers
               (layer (objects 2 3))))))

  (objects
    (decal (id 1) ...)
    (decal (id 2) ...)
    (decal (id 3) ...)
    ...)

* add shift-toggle to rotation to 90/180/270 degree, etc., pass
  GdkEvent modifier mask to control point

* things are getting messy, we have: 

   - hflip, vflip (works on UV)
   - scale
   - angle
  
  This all could be replaced with a translation matrix:

   + would make things more general

   - flipping via uv is trivial and doesn't lead to any trouble with
     float instability/snapping, could be easily extended to
     90/180/270 rotations (see Pingus source)

   - rotation and scale can't easily be reset or edited separately
     with matrix

   - float instability might lead to gaps between objects

* (id ...) is a string'ified pointer, while this work, this causes the
  levels to be different after each and every load/save cycle, which
  leads to ugly huge diff in SVN, should be something more constant

* add rectangle overlay that indicates the visible area of the game (i.e. one screen in current zoom size

* bounding rect doesn't rotate, controls don't rotate

* ControlPoint bounding rect scales, which it shouldn't, ControlPoint
  offset does to (scale and rotate handles get close together when
  zooming out)

* reduce icon padding in the ObjectSelector

* implement Blender-like grab-handles, that toggle between
  scale/rotation/etc., but also allow limit of move along the x- or
  y-axis only

* figure out how to properly draw controls in the Workspace (resize,
  rotation, vertices of a quad),

* make use of Statusbar
  - display mouse coordinates in WorldCo
  - display what Ctrl/Shift do for the current tool

* add more ways to snapping objects:

  - snap to snap-points
  - snap to integer positions (done, but should be optional, won't work with scale/rotate)
  - snap to grid (IMPORTANT)

* reevaluate the current parent/child implementation, since its very
  tricky currently to move a parent without affecting the child, which
  might be useful in some situation (i.e. hold Ctrl pressed to move
  only the parent, not the children). Other issues:

  - flipping doesn't work for parented objects when parent is in the
    selection

  - parents could be handled like normal objects, but with the
    SelectTool traversing all children and marking them before the
    move begings, Ctrl could be used to toggle this behaviour (sounds
    a little weird, we also don't have a way to iterate children from
    a parent)

  - having classic groups of objects, where clicking one object moves
    all in the group could be useful (like when each object is parent
    to each other object in the group), wouldn't allow an easy way to
    edit objects in the Group, which however might be a good thing

  - current parenthandling makes things like flipping much more complicated

* raise/lower of multiple objects at once is a bit wonky, when objects
  reach the bottom/top they will change their relative order in the
  selection (not a big deal with layers)

* set cursor in LayerManager when loading a level, as not setting it
  leads to crash and trouble

* QuadTree could be useful when levels get larger

* New Layer System:

  - normal Layers can contain child layers, which seems like a bad
    idea, better way would be to have special objectless parent layers

  - there might be a need for special layers, such as a background
    layer or a color gradient layer, that doesn't contain objects, but
    is meaningful by itself

* add button and keyboard shortcut to mark/unmark all layers in the layermask

* add a way to move object to a different layer

* drawing is broken after loading a level, only get fixed when
  toggling Light layer, (bug in OpenGLState maybe?)

* background pattern goes away when Color pattern is disabled, since
  its draw to the Colormap

* use last object in selection as parent instead of first? might be more natural

* use the right button for something

  - zoom tool: zoom out
  - select tool: context menu
    - delete object
    - duplicate object
    - parent object
    - move to different layer

* highlight content of rect selection while the rect gets dragged

* add way to refresh content of ObjectSelector (i.e. load new images
  from disk)

* highlight map is problematic, since objects don't cover highlights,
  maybe rendering a stencil mask might help, other alternative would
  be occulsion querys, but they only work for Geforce3 and Up. Have to
  wait and see how much of a problem that is in practice, ray-casting
  would be doable as well, but won't work well with 3d sprites or
  scaling

* add Blender like EmptyObjectModel

* spacenav support for scrolling?

* do a continous zoom while the zoom-button is pressed (timeout callback)

* ObjectProperty Dialog:

  Dialogs must be generic and usable by all Objects, supported type
  requirements:

  - Vector2f
  - std::string
  - Layer
  - Color
  - int
  - float
  - bool
  - enum

* add keyboard shortcut important stuff:

  - color, light, highlight toggle (1,2,3 are currently used up for the object selector)
  - next/previous layer: Ctrl-PageUp/Down

* add second toolbar, first one is getting a little crowded

* lightmap objects are hard to see (not that big an issue with the new
  layer system)

* decal needs to be scalable and have vertices moveable, also color
  needs to be adjustable

* make duplicated objects insert near those from which they where
  cloned (maybe have "Paste" and "Paste On Top")

* think about Undo/Redo

* implement non-Surface based objects:

   - seperate Surface stuff, turn it into a scaleable/rotatable decal quad
   - simple path
   - full NavigationGraph
   - Sprite
   - Sprite3d / Character

* ObjectSelector/IconView allows drag&drop even when nothing is
  selected, leading to a Grumbel dummy image drag&drop without effect

* add a way to draw objects to DrawingContext that only does
  translation, but not rotation and scaling, for use in UIElements,
  overlay text, etc.

* implement dialog to change level properties:

  - name
  - ambient color (Gtk::ColorSelection)
  - level size (?)

* SceneModel seems easier to implement then Sandbox'ing, maybe go with
  that first. TreeModel could be used directly to presenet the Scene,
  instead of trying to keep to things synced.

* Sandbox Pro&Contra:

  + very fast getting in and out of the game
  + edit game while it is running
  + no obscure version incompatibilty between editor and game objects
  + game editability can be reused in scripts

  - game and editor engine gets more complex

* Sandbox Implementation (similar to Feuerkraft):

  - add introspection to objects via PropertySets (see Feuerkraft),
    allows animation as well as easy editing and serialization
  - add a draw_editor() or a draw(bool editor)
  - some stuff for modifier handles

* make Windstille flexible enough so that it can work in non-SDL
  settings, more exactly it should be embeddable into a GtkWidget (or
  shall the editor be completly seperate?)

* should objects in the editor be based on real Windstille objects or
  on mookup objects?

* Editor Toolbar:

  - Visualize parent/child relationship (little arrows)
  - Object Properties

* Object List

  - plain image
  - prefabs
  - enemies
  - active objects (doors, switches, etc.)

Code Cleanup
============

* seperate and document components better:

  - collision engine
  - BabyXML
  - Sprite2D
  - Sprite3D
  - ParticleSystem
  - Dialog/Conversation

* Screens might fit better into app/ then screen/

* unify copyright header and #ifdef guards

 for i in */*.hpp; do echo $i; NAME=$(echo $i | sed "s/[\/\.]/_/g;s/^/HEADER_WINDSTILLE_/" | tr [a-z] [A-Z]);  sed  -i "s/^\(#[a-z]*\) *HEADER_WINDSTILLE_.*/\1 $NAME/" $i; done

* find a astyle/bcpp/whatever configuration that matches the current
  coding style, maybe a little script that uses Emacs would do

Sound Effects
=============

* sound of a large power switch being toggled

http://orange.blender.org/blog/the-amazing-incredible-monkey-brush#more-49
Hypatia

# EOF #
