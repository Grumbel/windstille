Windstille ToDo
===============

This is a list of tasks that need to be done in Windstille. However
this list is neither complete nor authoritative, so don't just blindly
implement things from this list, instead use this list just as guide
for things that might be worth to implement, but not necesarrily have
to. Some ideas in this list might actually be bad and better solved by
other means.

Scripting
=========

* ParticleSystem could be hooked up to scripting

* add a way to bind keys to script functions for use in debugging

  bind("F9", "toggle_this")
  bind("F9", function() { /* do stuff */ })

* maybe: introduce some cleaner seperation between scripts that are
  allowed to suspend and those that aren't

  - name them differently
  - name their trigger/hooks differently
  - remove suspendable functions from roottable
  - put suspendable functions into a different namespace
  - ...

* NavigationGraph needs hooks into scripting, so that things can be
  triggered when a character passes over a specific trigger node or
  things like that.

* add function that clears all scripts and rereads them from file (for
  debugging)

* add check that looks into a scripts root table to see if init()
  and/or run() is present

* add ability to wait on custom event and add ability to fire of a
  custom event:

    wait_for("bob arrives at bar");
    ...
    fire("bob arrives at bar");

  also add abilty for callbacks:

    register_callback("bob arrives at bar", function(){
       // do stuff
    });

  In which VM shall this be executed? In a new one? Wouldn't that be
  the same as:

    spawn_function(function(){
       // needed so that the callback can be called multiple times 
       while(true) { 
         wait_for("bob arrives at bar");
         // do stuff
       }
    });

  Also an ability to create unique events could be useful (not clear
  for exactly what, so implementation can wait):

    shared.event_id <- wait_for_unique_event()
    ...
    fire(shared.event_id);

* think about if scripts spawned in a sector should be parented to the
  sectors init script or to the root_vm, the later one is currently
  the case, the first one however would make it easier to share
  variables between scripts, on the other shared variable should often
  be available across sectors, so a better sharing mechanism is likely needed

  -> scripts could share state via a 'state' table defined in windstille.nut

* add option to SquirrelThread to be removed after its done or removed
  when a specific function is called (useful for spawning functions)

* reentering a sector twice barfs because:

  std::exception: Squirrel error: sectors/apartment/init.nut:
  SquirrelThread: couldn't call 'run' (sectors/apartment/flicker.nut:
  ScriptManager::run_script(): Script must be idle to be 'run()')

* ScriptableObject is a bad name, since all objects should be
  scriptable in one form or another

* implement more advanced tab-completion for console

* miniswig does not support __suspend with a return value, should be
  fixed, since Squirrel can handle it. Trouble is that the return
  value is created by the sq_wakeupvm() call, not by the
  sq_suspendvm() one, so its not actually in the wrapper code, but in
  the normal C++ code

  Return value has problem, works in same cases, but returns NULL for
  barrobot.nut in apartment.wst

* Currently we wakeup on conditions that are broadcasted to all
  scripts, in some situation it might make more sense to attach the
  script directly to the object that sends the signal

* some functions in data/scripts/windstille.nut require '::' before
  them so that they can be found, not quite clear why or exactly when
  this happens, seems to happen only in classes, not in normal
  function, in theory at least they should get resolved by delegation
  from the current environment to the roottable, but that doesn't
  happen

* objects are currently all exported to squirrel, while we should
  probally use id-tags and accessor functions instead:

  bob = get_object("barkeeper")
  bob.say()

* player can launch PDA or inventory when in a dialog, this will break
  the script

* currently the ScriptManager is global, meaning scripts are never
  cleaned up on Sector changes, this needs to be fixed

* figure out proper 'namespaces' for the scripting, i.e. gfx_ or
  video_ for all display related stuff and so on, so that
  tab-completion works better and things become more readable

* conversations really should be data with hooks for scripts, not pure
  scripts (FIXME: not clear if there is enough benefit and flexibilty
  to try that)

* print and println behave different on console (?)

Input Handling
==============

* input in Navigation Graph test uses deadzone, but shouldn't

* remove secondary controller, instead accept multiple --controller
  options and store the files in a list

* analog trigger handling is a little problematic, since the axis is
  neutral at -32768, not at 0.

* src/input/controller.hpp should keep not only the current state, but
  also the last state, this would allow proper detection of button
  presses and axis movements over a threshold

* Input deadzone is problematic when trying to get angle of a stick,
  deadzone needs to act different there then when X/Y are handled
  seperatly. Temporary workaround is to move deadzone out of the input
  code into the app code, which is problematic as well. Alternatives
  might be more high-level ways to access the stick:

  void get_stick_state(X_AXIS, Y_AXIS, &angle, &length);
  bool stick_is_centered(X_AXIS, Y_AXIS);
  float get_axis_state(X_AXIS, bool ignore_deadzone = false);

* change of input context is troublesome: when the user selects a
  dialog and confirms it, the character starts to walk into the
  direction that the player indicated, because the stick still points
  in that direction after OK_BUTTON is pressed.

  Possible solution: wait till the controller is in neutral position
  before sending events to the next Screen

* reconfigure the controls to behave like Tomb Raider (Xbox360 pad:
  A:jump, B:duck, X:run, Y:interact), move PDA elsewhere

* implement proper dead-zone in input handling

* allow to load multiple controller config files at once

* add zoom via xbox360 analog trigger buttons

* mouse support for menu

Sound Handling
==============

* split music, voice and sound fx into seperate context or allow to
  change their volume by other means

Miscellaneous
=============

* move has_suffix, has_prefix and stuff into StringUtil class

* get rid of global debug

* work on Object introspection, see: ~/projects/lang/c++/introspection.cpp

  class GameObject {
    PropertiesClass property_class() {
      static PropertyClass* this_class = 0;
      if (!this_class) {
                 
      } else {

      }
    }
    Properties properties() {
       static PropertiesClass this_class;
       if (!PropertiesClass 
    }
  }

* remove DEBUG macro or give it a clearer defined purpose, currently
  used only in a few tiny places

* add way to TextArea to layout text with a fixed indent after a linebreak:

  Bob: "Hi, how are you, yada yada yada yada yada yada
        yada yada yada yada yada yada yada yada yada yada
        yada yada yada"

* add Ctrl-k, Ctrl-k shortcuts to console

* save command history of the console between runs

* move the concept of parenting into .scm
  
  (scriptable-object 
       (parent "player")
       ...)

  tricky since parent name can't be resolved at object creation, only
  later

* extend the concept of parenting to other(all?) objects

* write "objects/decal.cpp" class, i.e. simple Surface class for
  non-animated objects:

  (decal (pos x y) 

         ;; relative to pos
         (quad x1 y1 ;; defaults to Rectf(Vector2f(0, 0), imagesize)
               x2 y2
               x3 y3
               x4 y4)
         (image "images/greychess.png")
         (layer "color")
         )

* Display::push/pop_cliprect() doesn't handle different aspect-ratios properly

* lightmap is broken with non-standard aspect-ratio

* why does src/navigation/node.hpp use SegmentPosition? Doesn't seem
  right

* set dynamic maximum size for auto resizing Menus depending on
  resolution

* add way to jump without running

* animation must be less strongly coupled to movement

* add way to skip through SpeechManager Speech lines (B-button)

* raycasting in laserpointer is broken, doesn't work if angle is 0
  (maybe not worth to fix since it will be replaced with
  NavigationMesh)

* get rid of global game_time variable

* map laserpointer to the second analog-stick, make mapping absolute,
  not relative

* maybe create an additional layer in SceneContext for drawing things
  like Speech and other worldspace GUI elements to it

* implement proper word wrap in SpeechManager and also add code to
  'unstuck' speech bubbles when they go over the window border.

  Also SpeechManager should act in worldspace, not screenspace or
  something clever inbetween.

* cleanup TextArea/text_area.cpp, having scrolling and running text
  together doesn't make all that much sense, also functions are too
  large

  Scrollbar is to far on the left, outside of the actual Rect, need to
  shrink horizontal width if text needs a scrollbar

* scrap inventory and redesign it

* When starting sector directly from command line, "Return to title screen" doesn't work

* console doesn't adopt to screen size

* create a UTF32 string class for use in console, basically
  basic_string<uint32_t> and a convert function to UTF-8 should be
  enough

* join Player and Character somewhat or derive one from the other, so
  that one can have scripted people running and jumping around

* implement aspect-ration switching at runtime (menu entry is there,
  just no code) and change default screen ration to that seen in the
  artwork pictures (FIXME: full resolution switch would be more useful
  then just aspect-ratio switch)

* add support for empty sectors (sectors without a player character,
  for use in intro.wst and similar cutscenes)

* HUD elements are whole screens, should be something simpler, also a
  seperation between HUD (energybar, speech, etc.) and Overlays
  (inventory, PDA, etc.) might be good

* do not save command line options given on the command line by
  default or add a --vanilla option or so

  or
   
  rewrite Config class and properly seperate config from command line
  and config done via option menu, i.e. command line settings
  shouldn't be persistent unless told so

* make lightmap resolution independent (done, but an artifact remains
  when the resolution isn't dividable by LIGHTMAP_DIV):

  1680x1050 -> 1050 / 4 -> 262.5 -> 262 * 4 -> 1048

  two pixel missing at the bottom

* Specify the capabilites that the different subsystems need to have

* make Console not derive from ostream

OpenGL
======

* check for features before using them:

glewInit();
if (glewIsSupported("GL_VERSION_2_0"))
printf("Ready for OpenGL 2.0\n");
else {
printf("OpenGL 2.0 not supported\n");
exit(1);
}

Profiling
=========

* figure out why running the game engine is extremely slow in
  valgrind, while pause menu is fast

* gprof results:

 16.90      0.60     0.60    47535     0.00     0.00  TileMap::draw(SceneContext&)
 15.21      1.14     0.54 37910690     0.00     0.00  VertexArrayDrawingRequest::texcoord(float, float)
 14.37      1.65     0.51 37974070     0.00     0.00  VertexArrayDrawingRequest::vertex(float, float, float)
 11.55      2.06     0.41    79225     0.00     0.00  Sprite3D::draw(Vector2f const&, Matrix const&) const
  3.94      2.20     0.14  1133610     0.00     0.00  OpenGLState::activate()

Bugs
====

* quickly tapping forward-back-hold down forward makes your character
  play the walking animation without actually moving anywhere
   
* Pressing left (or right), jump and and run at the same time throws an
  exception that causes the game to exit:

  std::exception: No marker with name 'RightFoot' defined in action 'Stand'

  in general the game shouldn't crash when stuff isn't found, but
  instead fallback to placeholders and give a error message on the console

* miniswig causes bison++ to crash

3D Things
==========

* bone animation

* change the game to a righthand coordinate system

Level Design
============

* fix the particle system in newformat2.wst, speed/lifetime is wrong

* implement light switches in apartment

  Currently the light switch-off sequence is done in the use script,
  this however makes it blocking, it would be nice if the switch-off
  sequence could be handled in a seperate script, but that would
  require a way to apport that script, since else a switch-on could
  collide with a switch-off script

  possible solution:

  function init() {
    lamp_sequence = spawn_script_norun("lamp_sequence.nut");
  }

  function init() {
      ...
      lamp_sequence.call("switch_on");
      ...
      lamp_sequence.call("switch_off");
      ...
  }

  The lamp_sequence.nut script would take control over the process and
  buffer call's when it is busy, once no longer busy it would pick the
  next task from the stack. Different scripts could use different
  stack behaviour, i.e. in the lamp_sequence() it would be useful to
  have a task-stack of size 1 and discard everything else.

  In addition to spawning a script, it would be good if there would be
  a way to spawn an object or a function, since that way the logic can
  be kept in one file.

  spawn_function(function() {
     obj <- FoobarObject();
     obj.run();
  })

* implement a door with two segments that slide sideways when the door
  opens, think about how that can be implemented properly in scripting
  (two parallel events that have to be waited for)

  -> a solution in scripting isn't a good idea here, this is something
     that would be much better solved by a 2D animation system
  

Random Things
=============

* add a music player that allows to play all music files of Windstille

* UTF8 support is missing in:
  
  - BabyXML
  - TTFFont
  - Console

* Add more markup to TextArea: (not really needed with LucasArts-like dialog)
    <font color="#ffbbcc"></font>: Use arbitary color
    <b></b>: make text properly bold
    <i></i>: make text properly italic 

* create a mission that is playable

* add line numbers to error messages from lisp

* rotation in 3d model viewer feels a little weird, could maybe be
  improved somehow

* using a non-square pixel aspect ratio leads to ugly fonts, fonts
  could be rendered with that aspect ratio in mind so that they are
  'pixel-perfect', instead of scaled by OpenGL. This requires:

  - a UI that is reasonably flexible to handle changes in font size
  - some code that scales/unscales the Font before drawing it

* update random number generator:
  http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html

Graphics
========

* Model lower-poly version of Jane and stuff

* aspect-ratio/resolution options:

  - let the user select a resolution from all the ones that are available from X11 (see Pingus for code)
  - have "aspect-ratio: auto" (calc from resolution) and 5:4, 4:3, 16:9, 16:10 overrides

* remodel titlescreen as 3D model

* setting glLineWidth() leads to some interesting artefacts on the
  menus which might be a cool effect

Editor
======

* add grid

* add a way to draw objects to DrawingContext that only does
  translation, but not rotation and scaling, for use in UIElements,
  overlay text, etc.

* implement dialog to change level properties:

  - name
  - ambient color (Gtk::ColorSelection)
  - level size (?)

* implement dialog to change objects properties

* figure out how to properly draw controls in the Workspace (resize,
  rotation, vertices of a quad),

* SceneModel seems easier to implement then Sandbox'ing, maybe go with
  that first. TreeModel could be used directly to presenet the Scene,
  instead of trying to keep to things synced.

* Sandbox Pro&Contra:

  + very fast getting in and out of the game
  + edit game while it is running
  + no obscure version incompatibilty between editor and game objects
  + game editability can be reused in scripts

  - game engine gets more complex

* Sandbox Implementation (similar to Feuerkraft):

  - add introspection to objects via PropertySets (see Feuerkraft),
    allows animation as well as easy editing and serialization
  - add a draw_editor() or a draw(bool editor)
  - some stuff for modifier handles

* make Windstille flexible enough so that it can work in non-SDL
  settings, more exactly it should be embeddable into a GtkWidget (or
  shall the editor be completly seperate?)

* should objects in the editor be based on real Windstille objects or
  on mookup objects?

* Editor Toolbox:

  - Object Select Tool (move objects around)
  - Object Manipulation Tool (move vertices in the object around)
  - Zoom Tool

* Editor Toolbar:

  - Visualize parent/child relationship (little arrows)
  - Object Properties

* Object List

  - plain image
  - prefabs
  - enemies
  - active objects (doors, switches, etc.)

* Layer List

  - display objects in the scene as tree
  - objects can be parented to each other
  - objects and object groups can be toggled invisible/transparent

Code Cleanup
============

* seperate and document components better:

  - collision engine
  - BabyXML
  - Sprite2D
  - Sprite3D
  - ParticleSystem
  - Dialog/Conversation

* Screens might fit better into app/ then screen/

* unify copyright header and #ifdef guards

 for i in */*.hpp; do echo $i; NAME=$(echo $i | sed "s/[\/\.]/_/g;s/^/HEADER_WINDSTILLE_/" | tr [a-z] [A-Z]);  sed  -i "s/^\(#[a-z]*\) *HEADER_WINDSTILLE_.*/\1 $NAME/" $i; done

* find a astyle/bcpp/whatever configuration that matches the current
  coding style, maybe a little script that uses Emacs would do


http://orange.blender.org/blog/the-amazing-incredible-monkey-brush#more-49
Hypatia

# EOF #
